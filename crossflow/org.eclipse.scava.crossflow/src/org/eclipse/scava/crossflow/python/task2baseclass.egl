[%import "../util.eol";
import "pythonUtil.eol";%]
import multiprocessing
import time

from crossflow.runtime import FailedJob, Task

[% for (t in outputTypes) { %]
from crossflow.[%=package%].[%=t.name.toSnakeCaseLower()%] import [%=t.name%]
[%}%]


class [%=t.name%]Base(Task):
    """NOTE: Auto-generated by [%=genRule%][%if (genDate.isDefined()) {%] on [%=genDate%][%}%]
    
    Do not edit this class manually
    """

<<<<<<< HEAD
	def __init__(self):
		super().__init__()
		self.workflow = None
		[%for (s in t.output) { %]
		self.[%=s.name.ftlc()%] = None
		[%}%]
	
	def setWorkflow(self, workflow):
		self.workflow = workflow
	
	def getWorkflow(self):
		return self.workflow
	
	def getId(self):
		return "[%=t.name%]:" + self.workflow.getName()
	
	[%for (s in t.output) { %]
	def set[%=s.name%](self, [%=s.name.ftlc()%]):
		self.[%=s.name.ftlc()%] = [%=s.name.ftlc()%]
	
	def get[%=s.name%](self):
		return self.[%=s.name.ftlc()%]
	
	def sendTo[%=s.name%](self, [%=s.type.name.ftlc()%]):
		[%=s.type.name.ftlc()%].setCacheable(self.cacheable)
		[%if(t.isTypeOf(Source)){%]
		[%=s.type.name.ftlc()%].setTransactional(False)
		[%}%]
		self.get[%=s.name%]().send([%=s.type.name.ftlc()%], self.__class__.__name__)
	
	[%}%]
	[%for (s in t.input) { %]
	def consume[%=s.name%]WithNotifications(self, [%=s.type.name.ftlc()%]):
		try:
			self.workflow.setTaskInProgessWithReason(self, [%=s.type.name.ftlc()%].getId())
	[%if(not t.multipleOutputs and t.output.size==1) {%]
			result = self.consume[%=s.name%]([%=s.type.name.ftlc()%]);
			if result is not None:
				if self.cacheable:
					result.setCorrelationId([%=s.type.name.ftlc()%].getId())
				result.setTransactional(False)
				self.sendTo[%=t.output.first.name%](result)
	[%}else {%]
			self.consume[%=s.name%]([%=s.type.name.ftlc()%])
	[%if(t.output.size>0) {%]
			conf = [%=t.output.first.type.name%]()
			conf.setCorrelationId([%=s.type.name.ftlc()%].getId())
			conf.setIsTransactionSuccessMessage(True)
			self.sendTo[%=t.output.first.name%](conf)
	[%}%]
	[%}%]
		except Exception as ex:
			self.workflow.local_logger.exception("")
			try:
				[%=s.type.name.ftlc()%].setFailures(int([%=s.type.name.ftlc()%].getFailures()) + 1)
				self.workflow.getFailedJobsTopic().send(FailedJob([%=s.type.name.ftlc()%], ex, self.workflow.getName(), "[%=t.name%]"))
			except Exception as e:
				self.workflow.local_logger.exception("")
				self.workflow.reportInternalException(e, "")
		finally:
			try:
				self.workflow.setTaskWaiting(self)
			except Exception as e:
				self.workflow.local_logger.exception("")
				self.workflow.reportInternalException(e, "")
	
	def consume[%=s.name%](self, [%=s.type.name.ftlc()%]):
		pass
	[%}%]
	
	[%if (t.isKindOf(Source)){%]
	def produce(self):
		pass
		
	[%}%]
	def close(self):
		pass
=======
    def __init__(self):
        super().__init__()
        self.workflow = None
        [%for (s in t.output) { %]
        self.[%=s.name.ftlc()%] = None
        self._has_sent_to_[%=s.pyVarName()%] = False
        [%}%]
    
    def setWorkflow(self, workflow):
        self.workflow = workflow
    
    def getWorkflow(self):
        return self.workflow
    
    def getId(self):
        return "[%=t.name%]:" + self.workflow.getName()
        
    def get_total_outputs(self):
        return sum([[%
        for (s in t.output) {
            out.print("self._has_sent_to_" + s.pyVarName());
            if (hasMore) {
                out.print(", ");
            }
        }%]])
    
    [%for (s in t.output) { %]
    def set[%=s.name%](self, [%=s.name.ftlc()%]):
        self.[%=s.name.ftlc()%] = [%=s.name.ftlc()%]
    
    def get[%=s.name%](self):
        return self.[%=s.name.ftlc()%]
    
    def sendTo[%=s.name%](self, [%=s.type.name.ftlc()%]):
        [%=s.type.name.ftlc()%].setCacheable(self.cacheable)
        [%if(t.isTypeOf(Source)){%]
        [%=s.type.name.ftlc()%].setTransactional(False)
        [%}%]
        self.get[%=s.name%]().send([%=s.type.name.ftlc()%], self.__class__.__name__)
    
    [%}%]
    [%for (s in t.input) { %]
    def consume[%=s.name%]WithNotifications(self, [%=s.type.name.ftlc()%]):
        [%for (o in t.output) {%]
        self._has_sent_to_[%=o.pyVarName()%] = False
        [%}%]
        
        try:
            def consumer():
                self.workflow.setTaskInProgessWithReason(self, [%=s.type.name.ftlc()%].getId())
            [%if (t.isSingleOut()) {%]
                result = self.consume[%=s.name%]([%=s.type.name.ftlc()%]);
                if result is not None:
                    if self.cacheable:
                        result.setCorrelationId([%=s.type.name.ftlc()%].getId())
                    result.setTransactional(False)
                    self.sendTo[%=t.output.first.name%](result)
            [%}else {%]
                self.consume[%=s.name%]([%=s.type.name.ftlc()%])
                
                [%for (o in t.output) {
                    var conf = o.pyVarName() + "_conf";%]
                [%=conf%] = [%=t.output.first.type.name%]()
                [%=conf%].setCorrelationId([%=s.type.name.ftlc()%].getId())
                [%=conf%].setIsTransactionSuccessMessage(True)
                [%=conf%].totalOutputs = self.get_total_outputs()
                if self._has_sent_to_[%=o.pyVarName()%]:
                    self.sendTo[%=o.name%]([%=conf%])
                    
                [%}
            }%]
            
            process = multiprocessing.Process(target=consumer)
            process.start()
            
            timeout = int([%=s.type.name.ftlc()%].timeout) if int([%=s.type.name.ftlc()%].timeout) > 0 else int(self.timeout)
            if timeout > 0:
                process.join(timeout)
                if process.is_alive():
                    process.terminate()
                    raise TimeoutError
            else:
                process.join()
            
        except Exception as ex:
            self.workflow.local_logger.exception("")
            try:
                send_failed = True
                if ex.__class__ == TimeoutError:
                    send_failed = self.on_consume_[%=s.pyVarName()%]_timeout([%=s.type.name.ftlc()%])
                
                if send_failed:
                    [%=s.type.name.ftlc()%].setFailures(int([%=s.type.name.ftlc()%].getFailures()) + 1)
                    self.workflow.getFailedJobsTopic().send(FailedJob([%=s.type.name.ftlc()%], ex, self.workflow.getName(), "[%=t.name%]"))
            
            except Exception as e:
                self.workflow.local_logger.exception("")
                self.workflow.reportInternalException(e, "")
        
        finally:
            try:
                self.workflow.setTaskWaiting(self)
            except Exception as e:
                self.workflow.local_logger.exception("")
                self.workflow.reportInternalException(e, "")
    
    def consume[%=s.name%](self, [%=s.type.name.ftlc()%]):
        pass
    
    def on_consume_[%=s.pyVarName()%]_timeout(self, [%=s.type.pyVarName()%]):
        return True
    [%}%]
    
    [%if (t.isKindOf(Source)){%]
    def produce(self):
        pass
        
    [%}%]
    def close(self):
        pass
>>>>>>> c947bbc9435fc5864f18aa3d3eb022c24f5ce930
