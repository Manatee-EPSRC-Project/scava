package [%=w.package%];

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Collection;
import java.util.List;
import java.util.LinkedList;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.DeliveryMode;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageListener;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;

import org.apache.activemq.command.ActiveMQDestination;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.eclipse.scava.crossflow.runtime.Workflow;
import org.eclipse.scava.crossflow.runtime.Job;
import org.eclipse.scava.crossflow.runtime.Stream;
import org.eclipse.scava.crossflow.runtime.Workflow.ChannelTypes;

public class [%=s.name%] extends Stream<[%=s.type.name%]> {
		
	public [%=s.name%](Workflow workflow) throws Exception {
		super(workflow);
		
		[%for (t in s.inputOf){%]
		pre.put("[%=t.name%]", (ActiveMQDestination) session.createQueue("[%=s.name%]Pre.[%=t.name%]." + workflow.getInstanceId()));
		destination.put("[%=t.name%]", (ActiveMQDestination) session.createQueue("[%=s.name%]Destination.[%=t.name%]." + workflow.getInstanceId()));
		post.put("[%=t.name%]", (ActiveMQDestination) session.create[%=s.eClass().name%]("[%=s.name%]Post.[%=t.name%]." + workflow.getInstanceId()));
		[%}%]
		
		for (String consumerId : pre.keySet()) {
			ActiveMQDestination preQueue = pre.get(consumerId);
			ActiveMQDestination destQueue = destination.get(consumerId);
			ActiveMQDestination postQueue = post.get(consumerId);
			
			if (workflow.isMaster()) {
				MessageConsumer preConsumer = session.createConsumer(preQueue);
				consumers.add(preConsumer);
				preConsumer.setMessageListener(new MessageListener() {
	
					@Override
					public void onMessage(Message message) {
						try {
							[%var isCached = not s.inputOf.exists(s|s.isTypeOf(Sink));%]
							[%if (isCached){%]
							Job job = (Job) ((ObjectMessage) message).getObject();
							if (workflow.getCache() != null && workflow.getCache().hasCachedOutputs(job)) {
								for (Job output : workflow.getCache().getCachedOutputs(job)) {
									
									[%for (next in s.inputOf.output.flatten()){%]
									if (output.getDestination().equals("[%=next.name%]")) {
										(([%=w.name%]) workflow).get[%=next.name%]().send(([%=next.type.name%]) output, consumerId);
									}
									[%}%]
									
								}
							} else {
							[%}%]
								MessageProducer producer = session.createProducer(destQueue);
								producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
								producer.send(message);
								producer.close();
							[%if (isCached){%]
							}
							[%}%]
							
						} catch (Exception ex) {
							ex.printStackTrace();
						}
					}
					
				});
				
				MessageConsumer destinationConsumer = session.createConsumer(destQueue);
				consumers.add(destinationConsumer);
				destinationConsumer.setMessageListener(new MessageListener() {
	
					@Override
					public void onMessage(Message message) {
						try {
							ObjectMessage objectMessage = (ObjectMessage) message;
							Job job = (Job) objectMessage.getObject();
							if (workflow.getCache() != null && !job.isCached()) {
								workflow.getCache().cache(job);
							}
							MessageProducer producer = session.createProducer(postQueue);
							producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
							producer.send(message);
							producer.close();
						}
						catch (Exception ex) {
							ex.printStackTrace();
						}
					}
					
				});
			}
		}
	}
	
	public void addConsumer([%=s.name%]Consumer consumer, String consumerId) throws Exception {
	
		ActiveMQDestination postQueue = post.get(consumerId);
		
		//only connect if the consumer exists (for example it will not in a master_bare situation)
		if(consumer!=null) {
		
			MessageConsumer messageConsumer = session.createConsumer(postQueue);
			consumers.add(messageConsumer);
			messageConsumer.setMessageListener(new MessageListener() {
		
				@Override
				public void onMessage(Message message) {
					ObjectMessage objectMessage = (ObjectMessage) message;
					try {
						[%=s.type.name%] [%=s.type.name.ftlc%] = ([%=s.type.name%]) objectMessage.getObject();
						consumer.consume[%=s.name%]WithNotifications([%=s.type.name.ftlc%]);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}	
			});
		}
	
	}

}